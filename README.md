# library_management_system
Разработано консольное приложение для управления библиотекой книг. Приложение позволяет добавлять, удалять, искать и отображать книги. 
Каждая книга содержит следующие поля: 
-book_id: Уникальный идентификатор книги. 
-title: Название книги. 
-author: Автор книги. 
-year: Год выпуска книги. 
-status: Статус книги ("в наличии","выдана").По умолчанию - "в наличии".
Основной код представлен в файле library_management.py: 
-Класс Book - описывает структуру книги и включает метод для преобразования объекта в словарь. 
-Класс Library - управляет коллекцией книг, включает функции для добавления, удаления, поиска, отображения и изменения статуса книг. 
-Методы работы с файлами - реализуют загрузку и сохранение книг в формате JSON. 
-Основное меню - предоставляет пользователю взаимодействие с библиотекой через консоль, обрабатывая введенные данные и вызывая соответствующие методы. 
-Обработка ошибок - используется конструкция try-except для корректной обработки ошибок (например, при удалении несуществующей книги). 
-Использовалась аннотации типов: добавлены аннотации типов для параметров и возвращаемых значений функций, что позволяет лучше понимать, какие типы данных используются. 
-В части документирования: добавлены строковые комментарии (docstrings) к классам и методам.Это обеспечивает ясное и краткое объяснение назначения метода и его параметров.
Структурированные тесты, которые проверяют работоспособность кода представлены в файле test_library.py, при этом использовались тестовые методы: 
-test_add_book: Проверяет добавление книги в библиотеку. 
-test_remove_book: Проверяет удаление книги. 
-test_search_books: Проверяет поиск книги по названию. 
-test_change_status: Проверяет изменение статуса книги. 
-test_save_load_file: Проверяет способность сохранять и загружать библиотеку из файла. 
Хранение данных в json формате представлено в файле library.json: 
Что бы русские буквы сохранялись в файле, не в виде Unicode, нужно указать в параметре ensure_ascii=False кода library_management.py.
Краткое описание кода в файле library_management.py: 
В представленной реализации уникальный идентификатор book_id генерируется автоматически при добавлении новой книги. В классе Library есть переменная экземпляра next_id,инициализируемая значением 1. Этот идентификатор будет использоваться как новый book_id при добавлении книг. При вызове метода add_book создаётся новый экземпляр класса Book, которому передаётся текущее значение next_id как book_id. После добавления книги в библиотеку значение next_id инкрементируется на 1, что позволяет обеспечить уникальность идентификаторов для будущих книг.Таким образом, каждый раз, когда Вы добавляете новую книгу, новый уникальный идентификатор будет автоматически присвоен, благодаря данному подходу. При этом идентификаторы будут последовательными, начиная с 1 и увеличиваясь на единицу с каждой добавленной книгой. Данные о книгах хранятся в формате JSON в файле с расширением .json. Это реализовано в методах save_to_file и load_from_file класса Library. Метод save_to_file преобразует список объектов Book в словари с помощью метода to_dict и записывает их в JSON файл. Загрузка книг из файла: Метод load_from_file читает данные из JSON файла и создает список объектов Book на основе загруженных данных. В случае, если файл не найден или содержимое не может быть декодировано, выводится соответствующее сообщение об ошибке. Инициализация аргумента filename функции save_to_file: Аргумент filename должен быть инициализирован в момент вызова функции, что в данном случае реализовано в методе main_menu, когда пользователь выбирает сохранить библиотеку в файл. При выборе действия "Сохранить и выйти", вызывается метод save_to_file, передавая строку "library.json" как аргумент.
Краткое описание кода в файле test_library.py: 
импортируем класс Library из файла library_management.py. Импортируем стандартную библиотеку unittest. Создаем Класс TestLibrary: Этот класс содержит все наши тесты и наследует от unittest.TestCase. Создаем Метод setUp: Этот метод выполняется перед каждым тестом. Здесь мы создаем новый экземпляр Library. Создаем тестовые методы (описаны выше) и метод tearDown: Этот метод выполняется после каждого теста и используется для очистки, например, удаления временно созданного файла. unittest.main() запускает все тесты.

